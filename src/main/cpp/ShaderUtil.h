#pragma once

#include "scene.h"
//////////贴图地面的SHADER///////////
const char TEXTURE_VERTEX_SHADER[]=
        "attribute vec4 position;   \n"
        "uniform float pointSize;  \n"
        //绘制的次数
        "uniform int drawScenePointer;  \n"
        "uniform float randNumber;   \n"
        "uniform mat4 ModelMatrix;\n"
        "uniform mat4 ViewMatrix;\n"
        "uniform mat4 ProjectionMatrix;\n"
        //点的经纬度值
        "attribute vec2 longLatitude;  \n"
        "attribute vec2 texcoord;  \n"
        "varying vec2 V_Texcoord;  \n"
        "varying vec2 V_longLatitude;  \n"
        "varying float V_drawScenePointer;   \n"
        "varying float V_randNumber;   \n"
        "void main(){\n"
        "   gl_Position=ProjectionMatrix*ViewMatrix*ModelMatrix*position; \n"
        "   V_Texcoord=texcoord;  \n"
        "   gl_PointSize = pointSize; \n"
        "   V_longLatitude= longLatitude;   \n"
        "   V_drawScenePointer=float(drawScenePointer);  \n"
        "   V_randNumber=randNumber;    \n"
        "}\n";
const char TEXTURE_FRAGMENT_SHADER[]=
        "#ifdef GL_ES \n"
        "precision mediump float; \n"
        "#endif   \n"
        "varying vec2 V_Texcoord; \n"
        "uniform sampler2D U_Texture;  \n"
        "uniform sampler2D lightWave_Texture;  \n"
        "varying vec2 V_longLatitude;  \n"
        "varying float V_drawScenePointer;   \n"
        "varying float V_randNumber;   \n"
        "void main(){ \n"
        "   float stRatio=V_drawScenePointer*V_longLatitude[0]*0.00003;       \n"
        "   gl_FragColor=texture2D(U_Texture,V_Texcoord)+texture2D(lightWave_Texture,V_Texcoord.st+vec2(stRatio,stRatio*2.0)); \n"
        "}\n";
/////////////////////////////////////////////////////
///////////绘制珊瑚的SHADER////////////////////////
const char DRAWCORAL_VERTEX_SHADER[]=
        "attribute vec4 position;   \n"
        "attribute vec4 positionNormal;   \n"
        "uniform vec3 lightPosition;     \n"
        "uniform vec3 cameraPosition;    \n"
        "uniform mat4 ModelMatrix;\n"
        "uniform mat4 ViewMatrix;\n"
        "uniform mat4 ProjectionMatrix;\n"
        "attribute vec2 texcoord;  \n"
        "varying vec2 V_Texcoord;  \n"
        "varying float nDot;\n"
        "varying float powerFactor;\n"
        "void main(){\n"
        "   vec3 v_Normal=normalize(vec3(positionNormal.x,positionNormal.y,positionNormal.z));                     \n"
        "   gl_Position=ProjectionMatrix*ViewMatrix*ModelMatrix*position; \n"
        "   vec3 vp= normalize(vec3(lightPosition.x, lightPosition.y, lightPosition.z)-vec3(position.x,position.y,position.z));\n"
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //计算从表面点到摄像机的向量
        "vec3 eye= normalize(vec3(cameraPosition.x,cameraPosition.y,cameraPosition.z)-vec3(position.x,position.y,position.z));   \n"
        "vec3 halfVector=normalize(eye+vp);	             \n"//求视线与光线的半向量
        "float nDotViewHalfVector=dot(v_Normal,halfVector);	  \n"//法线与半向量的点积
        "powerFactor=max(0.0,pow(nDotViewHalfVector,1.0));  \n"//镜面反射光强度因子
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        "   nDot=max(0.0,dot(v_Normal,vp));\n"
        "   V_Texcoord=texcoord;  \n"
        "}\n";
const char DRAWCORAL_FRAGMENT_SHADER[]=
        "#ifdef GL_ES \n"
        "precision mediump float; \n"
        "#endif   \n"
        "varying float nDot;\n"
        "varying float powerFactor;\n"
        "varying vec2 V_Texcoord; \n"
        "uniform sampler2D U_Texture;  \n"
        "void main(){ \n"
        "     vec4 texturePixel=texture2D(U_Texture,V_Texcoord);                \n"
        "     if((texturePixel[0]>0.9&&texturePixel[0]<0.91)&&(texturePixel[1]<0.86&&texturePixel[1]>0.84)&&(texturePixel[2]<0.001&&texturePixel[2]>=0.0)){  \n"
        "        texturePixel[3]=0.7;   \n"
        "        gl_FragColor=texturePixel; \n"
        "     }else{  "
        "        gl_FragColor=texturePixel+vec4(0.3,0.3,0.3,1.0)*nDot*0.7+vec4(0.3,0.3,0.3,1.0)*powerFactor*0.7; \n"
        "     }    \n"
        "}\n";
///////////////////////////////////////////////////////////////////
/////////////绘制点和线的SHADER//////////////////////////////////////
const char DRAWPOINTLINE_VERTEX_SHADER[]=
        "attribute vec3 position;   \n"
        "uniform float pointSize;  \n"
        "uniform float colorR; \n"
        "uniform float colorG; \n"
        "uniform float colorB; \n"
        "uniform mat4 ModelMatrix;\n"
        "uniform mat4 ViewMatrix;\n"
        "uniform mat4 ProjectionMatrix;\n"
        "varying float v_colorR; \n"
        "varying float v_colorG; \n"
        "varying float v_colorB; \n"
        "void main(){\n"
        "   gl_Position=ProjectionMatrix*ViewMatrix*ModelMatrix*vec4(position,1); \n"
        "   gl_PointSize = pointSize; \n"
        "   v_colorR=colorR;"
        "   v_colorG=colorG;"
        "   v_colorB=colorB;"
        "}\n";
const char DRAWPOINTLINE_FRAGMENT_SHADER[]=
        "#ifdef GL_ES \n"
        "precision mediump float; \n"
        "#endif   \n"
        "varying float v_colorR; \n"
        "varying float v_colorG; \n"
        "varying float v_colorB; \n"
        //"varying float powerFactor;\n"
       // "varying vec2 V_Texcoord; \n"
        "uniform sampler2D U_Texture;  \n"
        "void main(){ \n"
//        "   gl_FragColor=vec4(v_colorR,v_colorG,v_colorB,1.0); \n"
        "   gl_FragColor = texture2D(U_Texture, gl_PointCoord-vec2(0.5));"
        "}\n";
///////////////////////////////////////////////////
//////////////绘制耳朵眼睛和嘴的SHADER///////////
const char FLYELEPHANTEAR_VERTEX_SHADER[] =
        "attribute vec3 blinePoints1;        \n"
        "attribute vec3 blinePoints2;        \n"
        "attribute vec3 blinePoints3;        \n"
        "attribute vec3 blinePoints4;        \n"
        "attribute vec3 blinePercent;        \n"
        "uniform float blineSplit;           \n"
        "uniform mat4 ModelMatrix;           \n"
        "uniform mat4 ViewMatrix;            \n"
        "uniform mat4 ProjectionMatrix;      \n"
        "uniform vec3 lightPosition;         \n"
        "uniform int eyeEarMouthTag;         \n"


        "varying float eyeEarMouthTag_v;     \n"
        "varying float rowIndex_v;             \n"
        "void main()                         \n"
        "{                                   \n"
        "   float deltaT = 1.0 / blineSplit;                                                                           \n"
        "   float T = float(blinePercent[0]) * deltaT;                                                                  \n"
        "   float f1 = (-T*T*T + 3.0 * T*T - 3.0 * T + 1.0) / 6.0;                                               \n"
        "   float f2 = (3.0 * T*T*T - 6.0 * T*T + 4.0) / 6.0;                                                    \n"
        "   float f3 = (-3.0 * T*T*T + 3.0 * T*T + 3.0 * T + 1.0) / 6.0;                                         \n"
        "   float f4 = (T*T*T) / 6.0;                                                                            \n"
        "	float x = f1 * float(blinePoints1[0]) + f2 * float(blinePoints2[0]) + f3 * float(blinePoints3[0]) + f4 * float(blinePoints4[0]);  \n"
        "	float y = f1 * float(blinePoints1[1]) + f2 * float(blinePoints2[1]) + f3 * float(blinePoints3[1]) + f4 * float(blinePoints4[1]);  \n"
        "	float z = f1 * float(blinePoints1[2]) + f2 * float(blinePoints2[2]) + f3 * float(blinePoints3[2]) + f4 * float(blinePoints4[2]);  \n"
        "	vec4 position = vec4(x,y,z,1.0);                                                   \n"
        "   gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "	gl_PointSize = 4.0;                                                                \n"
        "   eyeEarMouthTag_v = float(eyeEarMouthTag);                                                  \n"
        "   rowIndex_v = float(blinePercent[1]);"

        "}                                                                                     \n"
;

const char FLYELEPHANTEAR_FRAGMENT_SHADER[] =
        "#ifdef GL_ES                                                              \n"
        "precision mediump float;                                                  \n"
        "#endif                                                                    \n"
        "varying float eyeEarMouthTag_v;                                            \n"
        "varying float rowIndex_v;                                                 \n"

        "void main()                                                               \n"
        "{                                                                         \n"
        //eyeEarMouthTag_v==0.0表示眼睛外圈
        "   if(eyeEarMouthTag_v==0.0){                                                \n"
        "       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);                            \n"
        //眼睛内圈
        "   }else if(eyeEarMouthTag_v==2.0){                                      \n"
        "       gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);                            \n"
        //耳朵
        "   }else if(eyeEarMouthTag_v==3.0){                                      \n"
        "       gl_FragColor = vec4(0.980392, 0.709803, 0.027451, 1.0);                            \n"
        "   }else if(eyeEarMouthTag_v==101.0){                                      \n"
        "       gl_FragColor = vec4(0.4745, 0.2313, 0.221, 1.0);                            \n"
        "   }else{                                                                 \n"
        //嘴
        "       gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);                               \n"
        "   }                                                                      \n"
        "}                                                                         \n";
/////////////////////////////////////////////////////////////////////////////////
////////////////绘制静态海草///////////////////////////
const char SEAGRASS_VERTEX_SHADER[] =
        "attribute vec3 blinePoints1;        \n"
        "attribute vec3 blinePoints2;        \n"
        "attribute vec3 blinePoints3;        \n"
        "attribute vec3 blinePoints4;        \n"
        "attribute vec3 blinePercent;        \n"
        "uniform float blineSplit;           \n"
        "uniform mat4 ModelMatrix;           \n"
        "uniform mat4 ViewMatrix;            \n"
        "uniform mat4 ProjectionMatrix;      \n"
        "uniform vec3 lightPosition;         \n"
        "uniform int seaGrassTag;  "
        "attribute vec2 texcoord;  \n"
        "varying vec2 V_Texcoord;  \n"
        "varying float V_seaGrassTag; "
        "void main()                         \n"
        "{                                   \n"
        "   float deltaT = 1.0 / blineSplit;                                                                           \n"
        "   float T = float(blinePercent[0]) * deltaT;                                                                  \n"
        "   float f1 = (-T*T*T + 3.0 * T*T - 3.0 * T + 1.0) / 6.0;                                               \n"
        "   float f2 = (3.0 * T*T*T - 6.0 * T*T + 4.0) / 6.0;                                                    \n"
        "   float f3 = (-3.0 * T*T*T + 3.0 * T*T + 3.0 * T + 1.0) / 6.0;                                         \n"
        "   float f4 = (T*T*T) / 6.0;                                                                            \n"
        "	float x = f1 * float(blinePoints1[0]) + f2 * float(blinePoints2[0]) + f3 * float(blinePoints3[0]) + f4 * float(blinePoints4[0]);  \n"
        "	float y = f1 * float(blinePoints1[1]) + f2 * float(blinePoints2[1]) + f3 * float(blinePoints3[1]) + f4 * float(blinePoints4[1]);  \n"
        "	float z = f1 * float(blinePoints1[2]) + f2 * float(blinePoints2[2]) + f3 * float(blinePoints3[2]) + f4 * float(blinePoints4[2]);  \n"
        "	vec4 position = vec4(x,y,z,1.0);                                                   \n"
        "   gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "   V_Texcoord=texcoord;                    \n"
        "	gl_PointSize = 8.0;                                                                \n"
        "   V_seaGrassTag=float(seaGrassTag);  "
        "}                                                                                     \n";

const char SEAGRASS_FRAGMENT_SHADER[] =
        "#ifdef GL_ES                                                              \n"
        "precision mediump float;                                                  \n"
        "#endif                                                                    \n"
        "uniform sampler2D U_Texture;                   \n"
        "varying vec2 V_Texcoord;                    \n"
        "varying float V_seaGrassTag; "
        "void main()                                                               \n"
        "{                                                                         \n"
        "     vec4 textureColor=texture2D(U_Texture,V_Texcoord);"
//        "     if(V_seaGrassTag>99.0){"
//        "        textureColor[3]=1.0;"
//        "     }else{"
        "       if(textureColor[0]<0.02&&textureColor[1]<0.02&&textureColor[2]<0.02){"
        "         textureColor[3]=0.0;"
        "       }else{"
        "         textureColor[3]=1.0;"
        "       }"
//        "     }"
        "     gl_FragColor=textureColor; \n"
        "}                                                                         \n";
/////////////////////////////////////////////////////////////////////////
////////////////绘制动态海草///////////////////////////
const char SEAGRASS_VERTEX_SHADER_MAP[] =
        "uniform mat4 ModelMatrix;           \n"
        "uniform mat4 ViewMatrix;            \n"
        "uniform mat4 ProjectionMatrix;      \n"
        "uniform int seaGrassTag;  "
        "attribute vec2 texcoord;  \n"
        "attribute vec4 positionV;                                                   \n"
        "varying vec2 V_Texcoord;  \n"
        "varying float V_seaGrassTag; "
        "void main()                         \n"
        "{                                   \n"
        "   gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*positionV;                    \n"
        "   V_Texcoord=texcoord;                    \n"
        "	gl_PointSize = 8.0;                                                                \n"
        "   V_seaGrassTag=float(seaGrassTag);  "
        "}                                                                                     \n";

const char SEAGRASS_FRAGMENT_SHADER_MAP[] =
        "#ifdef GL_ES                                                              \n"
        "precision mediump float;                                                  \n"
        "#endif                                                                    \n"
        "uniform sampler2D U_Texture;                   \n"
        "varying vec2 V_Texcoord;                    \n"
        "varying float V_seaGrassTag; "
        "void main()                                                               \n"
        "{                                                                         \n"
        "     vec4 textureColor=texture2D(U_Texture,V_Texcoord);"
        "     if(textureColor[0]<0.2&&textureColor[1]<0.2&&textureColor[2]<0.2){"//黑色底板
        "         textureColor[3]=0.0;"
        "     }else{"
        "         textureColor[3]=1.0;"
        "     }"
        "     gl_FragColor=textureColor; \n"
        "}                                                                         \n";
///////////////////////////////////////////////////
/////////////河豚SHADER////////////////////////////
const char BALLOONFISH_VERTEX_SHADER[] =
        "attribute vec3 blinePoints1;        \n"
        "attribute vec3 blinePoints2;        \n"
        "attribute vec3 blinePoints3;        \n"
        "attribute vec3 blinePoints4;        \n"
        "attribute vec3 blinePercent;        \n"
        "attribute vec2 texcoord;            \n"
        "uniform float blineSplit;           \n"
        "uniform mat4 ModelMatrix;           \n"
        "uniform mat4 ViewMatrix;            \n"
        "uniform mat4 ProjectionMatrix;      \n"
        "uniform vec3 lightPosition;         \n"
        "uniform int eyeEarMouthTag;         \n"
        "varying vec2 V_Texcoord;  \n"
        "varying float eyeEarMouthTag_v;     \n"
        "varying float rowIndex_v;             \n"
        "void main()                         \n"
        "{                                   \n"
        "   float deltaT = 1.0 / blineSplit;                                                                           \n"
        "   float T = float(blinePercent[0]) * deltaT;                                                                  \n"
        "   float f1 = (-T*T*T + 3.0 * T*T - 3.0 * T + 1.0) / 6.0;                                               \n"
        "   float f2 = (3.0 * T*T*T - 6.0 * T*T + 4.0) / 6.0;                                                    \n"
        "   float f3 = (-3.0 * T*T*T + 3.0 * T*T + 3.0 * T + 1.0) / 6.0;                                         \n"
        "   float f4 = (T*T*T) / 6.0;                                                                            \n"
        "	float x = f1 * float(blinePoints1[0]) + f2 * float(blinePoints2[0]) + f3 * float(blinePoints3[0]) + f4 * float(blinePoints4[0]);  \n"
        "	float y = f1 * float(blinePoints1[1]) + f2 * float(blinePoints2[1]) + f3 * float(blinePoints3[1]) + f4 * float(blinePoints4[1]);  \n"
        "	float z = f1 * float(blinePoints1[2]) + f2 * float(blinePoints2[2]) + f3 * float(blinePoints3[2]) + f4 * float(blinePoints4[2]);  \n"
        "	vec4 position = vec4(x,y,z,1.0);                                                   \n"
        "   gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "	gl_PointSize = 50.0;                                                                \n"
        "   eyeEarMouthTag_v = float(eyeEarMouthTag);                                                  \n"
        "   rowIndex_v = float(blinePercent[1]);"
        "   V_Texcoord=texcoord;                                                           \n"

        "}                                                                                     \n"
;

const char BALLOONFISH_FRAGMENT_SHADER[] =
        "#ifdef GL_ES                                                              \n"
        "precision mediump float;                                                  \n"
        "#endif                                                                    \n"
        "uniform sampler2D U_Texture;                   \n"
        "varying vec2 V_Texcoord;                    \n"
        "varying float eyeEarMouthTag_v;     \n"
        "varying float rowIndex_v;             \n"
        "void main()                                                               \n"
        "{                                                                         \n"
        "   gl_FragColor = texture2D(U_Texture,V_Texcoord);                               \n"
        "}                                                                         \n";

///////////////////////////////////////////////////
//////////////绘制耳朵眼睛和嘴的SHADER///////////
const char BALLOONFISH_STAB_VERTEX_SHADER[] =
        "attribute vec3 blinePoints1;        \n"
        "attribute vec3 blinePoints2;        \n"
        "attribute vec3 blinePoints3;        \n"
        "attribute vec3 blinePoints4;        \n"
        "attribute vec3 blinePercent;        \n"
        "uniform float blineSplit;           \n"
        "uniform mat4 ModelMatrix;           \n"
        "uniform mat4 ViewMatrix;            \n"
        "uniform mat4 ProjectionMatrix;      \n"
        "uniform vec3 lightPosition;         \n"
        "uniform int eyeEarMouthTag;         \n"
        "uniform float substractFactor;"
        "varying float eyeEarMouthTag_v;     \n"
        "varying float rowIndex_v;             \n"
        "void main()                         \n"
        "{                                   \n"
        "   float deltaT = 1.0 / blineSplit;                                                                           \n"
        "   float T = float(blinePercent[0]) * deltaT;                                                                  \n"
        "   float f1 = (-T*T*T + 3.0 * T*T - 3.0 * T + 1.0) / 6.0;                                               \n"
        "   float f2 = (3.0 * T*T*T - 6.0 * T*T + 4.0) / 6.0;                                                    \n"
        "   float f3 = (-3.0 * T*T*T + 3.0 * T*T + 3.0 * T + 1.0) / 6.0;                                         \n"
        "   float f4 = (T*T*T) / 6.0;                                                                            \n"
        "	float x = f1 * float(blinePoints1[0]) + f2 * float(blinePoints2[0]) + f3 * float(blinePoints3[0]) + f4 * float(blinePoints4[0]);  \n"
        "	float y = f1 * float(blinePoints1[1]) + f2 * float(blinePoints2[1]) + f3 * float(blinePoints3[1]) + f4 * float(blinePoints4[1]);  \n"
        "	float z = f1 * float(blinePoints1[2]) + f2 * float(blinePoints2[2]) + f3 * float(blinePoints3[2]) + f4 * float(blinePoints4[2]);  \n"


        "   float normalX=blinePoints1[0]-2.0*blinePoints2[0]+blinePoints3[0]+T*(3.0*blinePoints2[0]-blinePoints1[0]-3.0*blinePoints3[0]+blinePoints4[0]); \n"
        "   float normalY=blinePoints1[1]-2.0*blinePoints2[1]+blinePoints3[1]+T*(3.0*blinePoints2[1]-blinePoints1[1]-3.0*blinePoints3[1]+blinePoints4[1]); \n"
        "   float normalZ=blinePoints1[2]-2.0*blinePoints2[2]+blinePoints3[2]+T*(3.0*blinePoints2[2]-blinePoints1[2]-3.0*blinePoints3[2]+blinePoints4[2]); \n"
        "   int rowNum=int(blinePercent[1]);    \n"
        "   int pointNum=int(blinePercent[0]);    \n"
        //用来判断样条曲线点索引数的奇数偶数
        "   int multNum=-1;"
        "   for(int i=0;i<pointNum;i++){"
        "     multNum*=-1;"
        "   }"
        "   if(multNum>0){"
        "       if(rowNum==0||rowNum==2){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.006-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==4){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.13-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==6){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.15-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==8){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.17-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==10){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.18-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==12){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.18-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==14){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.18-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==16){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.18-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==18){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.18-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==20){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.17-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==22){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.16-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==24){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.15-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==26){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.13-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==28){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.11-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==30){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.09-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==32){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.09-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else if(rowNum==34){"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float stabLeng=0.07-substractFactor;"
        "          if(stabLeng<0.0){"
        "             stabLeng=0.0;"
        "          }"
        "          float ppx=x+stabLeng*norVect[0];"
        "          float ppy=y+stabLeng*norVect[1];"
        "          float ppz=z+stabLeng*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "      }else{"
        "          vec3 norVect=normalize(vec3(normalX,normalY,normalZ));   \n"
        "          float ppx=x+0.15*norVect[0];"
        "          float ppy=y+0.15*norVect[1];"
        "          float ppz=z+0.15*norVect[2];"
        "	       vec4 position = vec4(ppx,ppy,ppz,1.0);                                                   \n"
        "          gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "       }"
        "   }else{"
        "	    vec4 position = vec4(x,y,z,1.0);                                                   \n"
        "       gl_Position = ProjectionMatrix*ViewMatrix*ModelMatrix*position;                    \n"
        "   }"
        "	gl_PointSize = 4.0;                                                                \n"
        "   eyeEarMouthTag_v = float(eyeEarMouthTag);                                                  \n"
        "   rowIndex_v = float(blinePercent[1]);"

        "}                                                                                     \n"
;

const char BALLOONFISH_STAB_FRAGMENT_SHADER[] =
        "#ifdef GL_ES                                                              \n"
        "precision mediump float;                                                  \n"
        "#endif                                                                    \n"
        "varying float eyeEarMouthTag_v;                                            \n"
        "varying float rowIndex_v;                                                 \n"

        "void main()                                                               \n"
        "{                                                                         \n"
        "   gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);                               \n"
        "}                                                                         \n";

class ShaderUtil
{

public:
    ShaderUtil();
    ~ShaderUtil();
    void compGeomShader();
    void compDrawPointLineShader();
    void compDrawCoralShader();
    void compFlyElephantEarShader();
    GLuint compTextureShader();
    GLuint getGeomProgram();
    GLuint getDrawPointLineProgram();
    GLuint getDrawCoralProgram();
    GLuint getFlyElephantEarProgram();
    GLuint getTextureProgram();
    GLuint compSeaGrassShader();
    GLuint getSeaGrassProgram();
    GLuint compSeaGrassMapShader();
    GLuint getSeaGrassMapProgram();
    GLuint compBalloonFishShader();
    GLuint getBalloonFishProgram();
    GLuint compBalloonFishSTABShader();
    GLuint getBalloonFishSTABProgram();

    };
